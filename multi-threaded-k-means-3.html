<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Multi-threaded Algorithms - Home</title><meta name="description" content="For my parallel programming class's final project, I opted to take a well-known algorithm, K-Means Clustering, multi-thread it two different ways and compare the runtime performance between all three algorithms."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://jake-najera.github.io/jn-portfolio.github.io/multi-threaded-k-means-3.html"><link rel="alternate" type="application/atom+xml" href="https://jake-najera.github.io/jn-portfolio.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://jake-najera.github.io/jn-portfolio.github.io/feed.json"><meta property="og:title" content="Multi-threaded Algorithms"><meta property="og:site_name" content="Jake Najera's Portfolio"><meta property="og:description" content="For my parallel programming class's final project, I opted to take a well-known algorithm, K-Means Clustering, multi-thread it two different ways and compare the runtime performance between all three algorithms."><meta property="og:url" content="https://jake-najera.github.io/jn-portfolio.github.io/multi-threaded-k-means-3.html"><meta property="og:type" content="article"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://jake-najera.github.io/jn-portfolio.github.io/assets/css/style.css?v=04dda808058d62fabcb2aca989c83fdd"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://jake-najera.github.io/jn-portfolio.github.io/multi-threaded-k-means-3.html"},"headline":"Multi-threaded Algorithms","datePublished":"2021-04-01T12:38","dateModified":"2021-04-01T18:04","description":"For my parallel programming class's final project, I opted to take a well-known algorithm, K-Means Clustering, multi-thread it two different ways and compare the runtime performance between all three algorithms.","author":{"@type":"Person","name":"Jake Najera"},"publisher":{"@type":"Organization","name":"Jake Najera"}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://jake-najera.github.io/jn-portfolio.github.io/index.html">Home</a></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><h1>Multi-threaded Algorithms</h1></div></header></div><div class="wrapper post__entry"><p>For my parallel programming class's final project, I opted to take a well-known algorithm, K-Means Clustering, multi-thread it two different ways and compare the runtime performance between all three algorithms.</p><p> The standard K-Means algorithm consists of three steps:</p><ol><li>Assignment, assigning each sample to the nearest centroid by using Euclidean distance.</li><li>Update, recalculating the centroids and updating their positions.</li><li>Loop steps one and two if completion condition is not met.</li><li>Completion, determined by either achieving convergence or completing a fixed number of iterations.</li></ol><figure class="post__image post__image--center"><img loading="lazy" style="font-size: 18.4px; outline: 3px solid rgba(var(--primary-color-rgb), 0.55)  !important;" src="https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/Visualizer-2.gif" alt="" width="277" height="352"><figcaption>K-Means Completion, <a href="https://jake-najera.github.io/jn-portfolio.github.io/k-means-visualizer.html">Source</a></figcaption></figure><p>Let's begin by first talking about the applications of multi-threading used:</p><ul><li>We are looking to improve the <strong>execution time </strong>of the algorithm.</li><li>Multi-threading will <strong>not improve time complexity</strong>, the Big O notation of an algorithm will stay the same, as we are only applying factors onto Big O. An example would be that we have an O(n) algorithm. In theory, by using three threads in perfect parallel, it would be O(n/3), but since it is only a factor the notation would remain O(n) overall.</li><li><strong>Thread pools</strong> is key to saving time. Thread creation is time-expensive, as we'll see further below.</li><li><strong>Mutexes </strong>will be used to achieve <strong>mutual exclusion</strong> of container access, to avoid having multiple threads access a container at once and result in unstable race condition-based behavior.</li><li><strong>Semphores </strong>will be used in the form of a traffic light mechanism. Imagine that there is a one-way road with "T" number of lanes and a stoplight. The traffic light will stay red until all lanes are "filled", only then will it turn green. Returning back to threading, <strong>semaphores </strong>act as a synchronization tool that makes sure of all threads completing a task before moving on to another.</li><li><strong>Slicing</strong> or worker delegation is similar to how in Python one is able to slice arrays or a cake, we will cut the algorithm's workload into smaller chunks. The C++ benefit is that threads "own" their workload, achieving a true parallel workflow. A concept similar to <strong>mutexes</strong> in terms of <strong>mutual exclusion</strong>.</li></ul><h3>Approach #1: MT Centroid Update</h3><p>The first multi-threading approach speeds up execution time by executing the update step in parallel but with several pitfalls.</p><ol><li>Assignment.</li><li>Update, done in parallel by slicing the centroid container by T, the number of threads.</li><li>Barrier, wait until all threads are finished updating.</li><li>Loop steps one to three if completion condition is not met.</li><li>Completion, completed a fixed number of iterations.<figure class="post__image post__image--center"><img loading="lazy" src="https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/MTCU.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/MTCU-xs.png 300w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/MTCU-sm.png 480w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/MTCU-md.png 768w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/MTCU-lg.png 1024w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/MTCU-xl.png 1360w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/MTCU-2xl.png 1600w" alt="" width="501" height="367"></figure></li></ol><p>This approach suffers from the assignment step being single threaded and that threads are being created every iteration.</p><h3>Approach #2: MT Workers Parallelization</h3><p>The second and final multi-threading approach speeds up execution time by executing the assignment and update steps in parallel using slicing and barriers.</p><ol><li>Intialize thread pool.</li><li>Assignment, done in parallel by slicing the sample container by T, the number of threads.</li><li>Barrier, wait until all threads are finished assigning.</li><li>Update, done in parallel by slicing the centroid container by T, the number of threads.</li><li>Barrier, wait until all threads are finished updating.</li><li>Repeat steps two to five if completion condition is not met.</li><li>Completion, completed a fixed number of iterations.</li></ol><figure class="post__image post__image--center"><img loading="lazy" src="https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/MTWP-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/MTWP-2-xs.png 300w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/MTWP-2-sm.png 480w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/MTWP-2-md.png 768w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/MTWP-2-lg.png 1024w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/MTWP-2-xl.png 1360w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/MTWP-2-2xl.png 1600w" alt="" width="470" height="358"></figure><h3>Results:</h3><p>After completing both approaches, I ran tests on all three algorithm versions, with varying number of clusters and samples and performed an algorithm analysis using Bash for execution timing and Tableau for visualization, here's a snippet:</p><figure class="post__image"><img loading="lazy" src="https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/Cluster-Comparison.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/Cluster-Comparison-xs.png 300w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/Cluster-Comparison-sm.png 480w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/Cluster-Comparison-md.png 768w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/Cluster-Comparison-lg.png 1024w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/Cluster-Comparison-xl.png 1360w, https://jake-najera.github.io/jn-portfolio.github.io/media/posts/13/responsive/Cluster-Comparison-2xl.png 1600w" alt="" width="1585" height="925"></figure><p>The full analysis document can be found <a href="https://github.com/jake-najera/MultithreadedKMeans/blob/main/Analytical%20Findings/Analysis.pdf" title="https://github.com/jake-najera/MultithreadedKMeans/blob/main/Analytical%20Findings/Analysis.pdf">here</a>, the Tableau dashboards <a href="https://public.tableau.com/views/Multi-ThreadedK-MeansProject/ClusterComparison?:language=en&amp;:display_count=y&amp;:toolbar=n&amp;:origin=viz_share_link">here</a>, and the codebase <a href="https://github.com/jake-najera/MultithreadedKMeans">here</a>. As a whole, I really enjoyed the challenges that this project prompted, and feel very satisified with my findings.</p></div><footer class="wrapper post__footer"><ul class="post__tag"><li><a href="https://jake-najera.github.io/jn-portfolio.github.io/tags/c/index.html">C++</a></li><li><a href="https://jake-najera.github.io/jn-portfolio.github.io/tags/tableau/index.html">Tableau</a></li></ul><div class="post__share"></div><div class="post__bio bio"><div class="bio__info"><h3 class="bio__name"><a href="https://jake-najera.github.io/jn-portfolio.github.io/authors/jake-najera/index.html" class="invert" rel="author">Jake Najera</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://jake-najera.github.io/jn-portfolio.github.io/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://jake-najera.github.io/jn-portfolio.github.io/twitchscraper-2.html" class="invert post__nav-link" rel="prev"><span>Previous</span> TwitchScraper</a></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>Powered by <a href="https://getpublii.com" target="_blank" rel="nofollow noopener">Publii</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://jake-najera.github.io/jn-portfolio.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://jake-najera.github.io/jn-portfolio.github.io/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>